package chaincode

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/hyperledger/fabric-contract-api-go/v2/contractapi"
)

// 1. Prefix changes in the keystorage
// OWNER_ and ASSET_ are used as prefix in the world state
type SmartContract struct {
	contractapi.Contract
}

// Asset describes basic details of what makes up a simple asset
// Insert struct field in alphabetic order => to achieve determinism across languages
// golang keeps the order when marshal to json but doesn't order automatically
type Asset struct {
	AppraisedValue int       `json:"appraisedValue"`
	Color          string    `json:"color"`
	ID             string    `json:"ID"`
	Owner          string    `json:"owner"`
	OwnerID        string    `json:"ownerID"` // id is uuid of owner
	Size           int       `json:"size"`
	OffChainDataID string    `json:"offChainDataID"`
	CreatedAt      time.Time `json:"createdAt"`
	UpdatedAt      time.Time `json:"updatedAt"`
}

type Owner struct {
	ID                 string    `json:"ID"`
	Name               string    `json:"name"`
	OffChainUserDataID string    `json:"offChainUserDataID"`
	CreatedAt          time.Time `json:"createdAt"`
	UpdatedAt          time.Time `json:"updatedAt"`
}

// InitLedger adds a base set of assets to the ledger
func (s *SmartContract) InitLedger(ctx contractapi.TransactionContextInterface) error {

	// Initial owners
	ownerIDs := make(map[string]string) // map to store owner's name and their generated id
	owners := []Owner{
		{
			// ID: uuid.New().String(),
			ID:                 "7a266082-94bd-4426-8681-a1e65d17fd68",
			Name:               "Tomoko",
			OffChainUserDataID: "",
			// time might in consistency as well i guess
			// CreatedAt:          time.Now().UTC(),
			// UpdatedAt:          time.Now().UTC(),
			CreatedAt: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			UpdatedAt: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
		},
		{
			// ID: uuid.New().String(),
			ID:                 "7a266082-94bd-4426-8681-a1e65d17fd69",
			Name:               "Brandon",
			OffChainUserDataID: "",
			// CreatedAt:          time.Now().UTC(),
			// UpdatedAt:          time.Now().UTC(),
			CreatedAt: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
			UpdatedAt: time.Date(2024, 1, 1, 0, 0, 0, 0, time.UTC),
		},
	}
	for _, owner := range owners {
		// Store owner in the map
		ownerIDs[owner.Name] = owner.ID
		ownerJSON, err := json.Marshal(owner)
		if err != nil {
			return fmt.Errorf("failed to marshal owner : %v", err)
		}
		// err = ctx.GetStub().PutState(owner.ID, ownerJSON)
		// we want ways to categorized the owner and asset in the world state
		err = ctx.GetStub().PutState(fmt.Sprintf("OWNER_%s", owner.ID), ownerJSON)
		if err != nil {
			return fmt.Errorf("failed to put owner to the world state : %v", err)
		}
	}

	assets := []Asset{
		{ID: "asset1",
			Color:          "blue",
			Size:           5,
			Owner:          "Tomoko",
			OwnerID:        ownerIDs["Tomoko"],
			AppraisedValue: 300},
		{ID: "asset2",
			Color:          "orange",
			Size:           5,
			Owner:          "Brandon",
			OwnerID:        ownerIDs["Brandon"],
			AppraisedValue: 400},
	}

	for _, asset := range assets {
		assetJSON, err := json.Marshal(asset)
		if err != nil {
			return err
		}

		// err = ctx.GetStub().PutState(asset.ID, assetJSON)
		// Same goes for this case as well
		err = ctx.GetStub().PutState(fmt.Sprintf("ASSET_%s", asset.ID), assetJSON)
		if err != nil {
			return fmt.Errorf("failed to put to world state. %v", err)
		}
	}

	return nil
}

// Related to Owner ðŸ˜„
func (s *SmartContract) OwnerExists(ctx contractapi.TransactionContextInterface,
	id string) (bool, error) {
	// we have to defined specific prefix in order to get the id
	// ownerJSON, err := ctx.GetStub().GetState(id)
	ownerJSON, err := ctx.GetStub().GetState(fmt.Sprintf("OWNER_%s", id))
	if err != nil {
		return false, fmt.Errorf("Failed to read from world state: %v", err)
	}
	return ownerJSON != nil, nil
}

// why not generated the id here, because id is generated by the client from the api
func (s *SmartContract) CreateOwner(ctx contractapi.TransactionContextInterface,
	id,
	name,
	offChainUserDataID string) (Owner, error) {

	// id := uuid.New().String()
	txTimestamp, err := ctx.GetStub().GetTxTimestamp()
	exists, err := s.OwnerExists(ctx, id)
	if err != nil {
		return Owner{}, fmt.Errorf("failed to check if the owner exists : %v",
			err)
	}
	if exists {
		return Owner{}, fmt.Errorf("the owner %s already exists", id)
	}
	owner := Owner{
		ID:                 id,
		Name:               name,
		OffChainUserDataID: offChainUserDataID,
		// CreatedAt:          time.Now().UTC(),
		// UpdatedAt:          time.Now().UTC(),
		CreatedAt: time.Unix(int64(txTimestamp.Seconds),
			int64(txTimestamp.Nanos)).UTC(),
		UpdatedAt: time.Unix(int64(txTimestamp.Seconds),
			int64(txTimestamp.Nanos)).UTC(),
	}

	ownerJSON, err := json.Marshal(owner)
	if err != nil {
		return Owner{},
			fmt.Errorf("failed to mashal owner : %v", err)
	}

	// err = ctx.GetStub().PutState(id, ownerJSON)
	err = ctx.GetStub().PutState(fmt.Sprintf("OWNER_%s", id), ownerJSON)
	if err != nil {
		return Owner{},
			fmt.Errorf("failed to put owner to world state : %v", err)
	}

	return owner, nil

}

func (s *SmartContract) ReadOwner(ctx contractapi.TransactionContextInterface,
	id string) (*Owner, error) {

	ownerJSON, err := ctx.GetStub().GetState(id)
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state : %v", err)
	}
	if ownerJSON == nil {
		return nil, fmt.Errorf("the owner %s does not exist", id)
	}

	var owner Owner
	err = json.Unmarshal(ownerJSON, &owner)
	if err != nil {
		return nil, err
	}

	return &owner, nil
}

func (s *SmartContract) UpdateOwner(ctx contractapi.TransactionContextInterface,
	id string,
	name string, offChainUserDataID string) error {

	owner, err := s.ReadOwner(ctx, id)
	if err != nil {
		return err
	}

	owner.Name = name
	owner.OffChainUserDataID = offChainUserDataID
	owner.UpdatedAt = time.Now().UTC()

	ownerJSON, err := json.Marshal(owner)
	if err != nil {
		return fmt.Errorf("failed to marshal owner : %v", err)
	}
	return ctx.GetStub().PutState(id, ownerJSON)

}

func (s *SmartContract) getItemsByPrefix(ctx contractapi.TransactionContextInterface,
	prefix string,
	itemType interface{}) ([]interface{}, error) {
	resultIterator, err := ctx.GetStub().GetStateByRange("", "")
	// resultIterator, err := ctx.
	// 	GetStub().
	// 	GetStateByPartialCompositeKey(prefix, []string{})
	if err != nil {
		return nil, fmt.Errorf("failed to get all keys : %v", err)
	}
	defer resultIterator.Close()
	var items []interface{}
	for resultIterator.HasNext() {
		queryResponse, err := resultIterator.Next()
		if err != nil {
			return nil, fmt.Errorf("failed to get the next key-value : %v", err)
		}
		if strings.HasPrefix(queryResponse.Key, prefix) {
			// item := itemType
			item := reflect.New(reflect.TypeOf(itemType).Elem()).Interface()
			// err = json.Unmarshal(queryResponse.Value, &item)
			err = json.Unmarshal(queryResponse.Value, item)
			if err != nil {
				return nil, fmt.Errorf("failed to unmarshal item: %v", err)
			}
			items = append(items, item)
		}
	}

	return items, nil

}

func (s *SmartContract) GetAllOwners(ctx contractapi.TransactionContextInterface) ([]*Owner, error) {
	items, err := s.getItemsByPrefix(ctx, "OWNER_", &Owner{})
	if err != nil {
		return nil, fmt.Errorf("failed to get all owners : %v", err)
	}
	owners := make([]*Owner, len(items))
	for i, item := range items {
		owners[i] = item.(*Owner)
	}
	return owners, nil
}

/*
	 This is the older versions
		 func (s *SmartContract) GetAllOwners(ctx contractapi.TransactionContextInterface) ([]*Owner, error) {
			resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
			if err != nil {
				return nil, err
			}
			defer resultsIterator.Close()

			var owners []*Owner
			for resultsIterator.HasNext() {
				queryResponse, err := resultsIterator.Next()
				if err != nil {
					return nil, err
				}
				var owner Owner
				err = json.Unmarshal(queryResponse.Value, &owner)
				if err != nil {
					return nil, err
				}
				owners = append(owners, &owner)
			}
			return owners, nil
		}
*/
func (s *SmartContract) GetOwner(ctx contractapi.TransactionContextInterface,
	id string) (*Owner, error) {
	ownerJSON, err := ctx.
		GetStub().
		GetState(fmt.Sprintf("OWNER_%s", id))
	if err != nil {
		return nil,
			fmt.Errorf("failed to read from world state: %v", err)
	}
	if ownerJSON == nil {
		return nil,
			fmt.Errorf("the owner %s does not exist", id)
	}

	var owner Owner
	err = json.Unmarshal(ownerJSON, &owner)
	if err != nil {
		return nil, err
	}
	return &owner, nil
}

// GetAssetHistory returns the histroy of an assets in the world state
func (s *SmartContract) GetAssetHistory(ctx contractapi.TransactionContextInterface,
	id string) ([]Asset, error) {
	assetKey := fmt.Sprintf("ASSET_%s", id)
	resultsIterator, err := ctx.GetStub().
		GetHistoryForKey(assetKey)
	if err != nil {
		return nil,
			fmt.Errorf("failed to get history for asset %s: %v ", id, err)
	}

	defer resultsIterator.Close()
	var history []Asset
	for resultsIterator.HasNext() {
		response, err := resultsIterator.Next()
		if err != nil {
			return nil,
				fmt.Errorf("Failed to iterate through history : %v", err)
		}

		var asset Asset
		err = json.Unmarshal(response.Value, &asset)
		if err != nil {
			return nil, fmt.Errorf("failed to unmarshal asset : %v", err)
		}
		history = append(history, asset)
	}
	return history, nil
}

// CreateAsset issues a new asset to the world state with given details.
func (s *SmartContract) CreateAsset(ctx contractapi.TransactionContextInterface,
	id string,
	color string,
	size int,
	ownerId string,
	appraisedValue int,
	offChainDataID string) error {
	exists, err := s.AssetExists(ctx, id)
	if err != nil {
		return err
	}
	if exists {
		return fmt.Errorf("the asset %s already exists", id)
	}

	owner, err := s.GetOwner(ctx, ownerId)
	if err != nil {
		return fmt.Errorf("the owner %s does not exist", ownerId)
	}

	txTimestamp, err := ctx.GetStub().GetTxTimestamp()
	asset := Asset{
		ID:    id,
		Color: color,
		Size:  size,
		// Owner:   "default ownername",
		// OwnerID: "default ownerId",
		Owner:          owner.Name,
		OwnerID:        owner.ID,
		AppraisedValue: appraisedValue,
		OffChainDataID: offChainDataID,
		// CreatedAt:      time.Now().UTC(),
		// UpdatedAt:      time.Now().UTC(),
		CreatedAt: time.Unix(int64(txTimestamp.Seconds),
			int64(txTimestamp.Nanos)).UTC(),
		UpdatedAt: time.Unix(int64(txTimestamp.Seconds),
			int64(txTimestamp.Nanos)).UTC(),
	}
	assetJSON, err := json.Marshal(asset)
	if err != nil {
		return err
	}

	// PutState is used in order to write the asset to the world state
	return ctx.GetStub().
		PutState(fmt.Sprintf("ASSET_%s", id), assetJSON)
}

// ReadAsset returns the asset stored in the world state with given id.
func (s *SmartContract) ReadAsset(ctx contractapi.TransactionContextInterface, id string) (*Asset, error) {
	// assetJSON, err := ctx.GetStub().GetState(id)
	assetJSON, err := ctx.GetStub().GetState(fmt.Sprintf("ASSET_%s", id))
	if err != nil {
		return nil, fmt.Errorf("failed to read from world state: %v", err)
	}
	if assetJSON == nil {
		return nil, fmt.Errorf("the asset %s does not exist", id)
	}

	var asset Asset
	err = json.Unmarshal(assetJSON, &asset)
	if err != nil {
		return nil, err
	}

	return &asset, nil
}

// UpdateAsset updates an existing asset in the world state with provided parameters.
func (s *SmartContract) UpdateAsset(ctx contractapi.TransactionContextInterface,
	id string, color string, size int, ownerID string,
	appraisedValue int, offChainDataId string) error {
	exists, err := s.AssetExists(ctx, id)
	if err != nil {
		return err
	}
	if !exists {
		return fmt.Errorf("the asset %s does not exist", id)
	}

	owner, err := s.ReadOwner(ctx, ownerID)
	if err != nil {
		return fmt.Errorf("the owner %s does not exist", ownerID)
	}

	// overwriting original asset with new asset
	asset := Asset{
		ID:             id,
		Color:          color,
		Size:           size,
		Owner:          owner.Name,
		OwnerID:        owner.ID,
		AppraisedValue: appraisedValue,
		OffChainDataID: offChainDataId,
		UpdatedAt:      time.Now().UTC(), // this should cause error
	}
	assetJSON, err := json.Marshal(asset)
	if err != nil {
		return fmt.Errorf("failed to marshal asset : %v", err)
	}

	return ctx.GetStub().PutState(fmt.Sprintf("ASSET_%s", id), assetJSON)
}

// DeleteAsset deletes an given asset from the world state.
func (s *SmartContract) DeleteAsset(ctx contractapi.TransactionContextInterface, id string) error {
	exists, err := s.AssetExists(ctx, id)
	if err != nil {
		return err
	}
	if !exists {
		return fmt.Errorf("the asset %s does not exist", id)
	}

	return ctx.GetStub().DelState(fmt.Sprintf("ASSET_%s", id))
}

// AssetExists returns true when asset with given ID exists in world state
func (s *SmartContract) AssetExists(ctx contractapi.TransactionContextInterface,
	id string) (bool, error) {
	assetJSON, err := ctx.
		GetStub().
		GetState(fmt.Sprintf("ASSET_%s", id))
	if err != nil {
		return false,
			fmt.Errorf("failed to read from world state: %v", err)
	}

	return assetJSON != nil, nil
}

// TransferAsset updates the owner field of asset with given id in world state, and returns the old owner.
func (s *SmartContract) TransferAsset(
	ctx contractapi.TransactionContextInterface,
	id string,
	newOwnerID string) (string, error) {

	// assetId := fmt.Sprintf("ASSET_%s", id)
	asset, err := s.ReadAsset(ctx, id)
	if err != nil {
		return "", err
	}
	//newOwnerId := fmt.Sprintf("OWNER_%s", newOwnerID)
	newOwner, err := s.GetOwner(ctx, newOwnerID)
	if err != nil {
		return "", fmt.Errorf("the owner %s does not exist", newOwnerID)
	}

	txTimestamp, err := ctx.
		GetStub().
		GetTxTimestamp()
	oldOwner := asset.Owner
	asset.OwnerID = newOwner.ID
	asset.Owner = newOwner.Name
	asset.UpdatedAt = time.
		Unix(int64(txTimestamp.Seconds),
			int64(txTimestamp.Nanos)).UTC()

	assetJSON, err := json.Marshal(asset)
	if err != nil {
		return "", err
	}

	err = ctx.GetStub().
		PutState(fmt.Sprintf("ASSET_%s", id), assetJSON)
	if err != nil {
		return "", err
	}

	return oldOwner, nil
}

func (s *SmartContract) GetAllAssets(ctx contractapi.TransactionContextInterface) ([]*Asset, error) {
	items, err := s.getItemsByPrefix(ctx, "ASSET_", &Asset{})
	if err != nil {
		return nil, fmt.Errorf("failed to get all assets : %v", err)
	}
	assets := make([]*Asset, len(items))
	for i, item := range items {
		assets[i] = item.(*Asset)
	}
	return assets, nil
}

// GetAllAssets returns all assets found in world state
/* func (s *SmartContract) GetAllAssets(ctx contractapi.TransactionContextInterface) ([]*Asset, error) {
	// range query with empty string for startKey and endKey does an
	// open-ended query of all assets in the chaincode namespace.
	resultsIterator, err := ctx.GetStub().GetStateByRange("", "")
	if err != nil {
		return nil, err
	}
	defer resultsIterator.Close()

	var assets []*Asset
	for resultsIterator.HasNext() {
		queryResponse, err := resultsIterator.Next()
		if err != nil {
			return nil, err
		}

		var asset Asset
		err = json.Unmarshal(queryResponse.Value, &asset)
		if err != nil {
			return nil, err
		}
		assets = append(assets, &asset)
	}

	return assets, nil
} */
